#! /usr/bin/env node

/**
 * This file automatically generates the MDX docs for storybook from any
 * markdown files in the '/docs' directory or any file added to the
 * 'includes' array.
 */

const fs = require('fs');
const path = require('path');
const rimraf = require('rimraf');
const camelCase = require('camelcase');

const includes = ['README.md', './docs'];

const output = './.storybook/.docs';

const rootReadMe = `
# What's this?

This folder is where the MDX versions of the files in the docs folder are stored.
It is automatically generated by by the 'gendocs' script and can safely
be ignored.
`;

const formatName = (fileName) => {
  return camelCase(fileName, { pascalCase: true })
    .replace(/([A-Z][a-z])/g, ' $1')
    .replace(/(\d)/g, ' $1')
    .trim();
};
// read all files in the includes array and if they are markdown files, process them
// if it s a directory, recursively read all files in the directory and start again
const recurseDirectories = (file) => {
  if (fs.statSync(file).isDirectory()) {
    const dirs = fs.readdirSync(file);
    return dirs.forEach((dir) => recurseDirectories(path.join(file, dir)));
  }

  const filePath = path.resolve(__dirname, file);
  const fileContents = fs.readFileSync(filePath, 'utf8');
  const baseFileName = path.basename(filePath);
  let dirName = filePath
    .replace(`/${baseFileName}`, '')
    .replace(__dirname, '')
    .replace(`/docs/`, '')
    .trim();

  dirName = formatName(dirName);
  let pageTitle = baseFileName.replace('.md', '');
  pageTitle = formatName(pageTitle);

  pageTitle === 'Readme' && (pageTitle = 'Introduction');
  pageTitle === 'Index' && (pageTitle = 'Introduction');

  const metaTitle = dirName ? `${dirName}/${pageTitle}` : pageTitle;

  let convertedContent = `import { Meta, Description } from '@storybook/addon-docs';\n\n`;
  convertedContent += `<Meta title="Docs/${metaTitle}" />\n\n`;
  fileContents.split('\n').forEach((line) => {
    const regex = /\[([\Ss ]+)\]\((.\/[a-z-/]+.md)\)/;
    if (regex.test(line)) {
      const [, , link] = line.match(regex);
      const directory = dirName.replace(' ', '-').toLowerCase();
      let convertedLink = link
        .replace(/\.\/(docs)?\/*/, '@temp@')
        .replace(/\//g, '-')
        .replace('.md', '--page');
      if (!directory) {
        convertedLink = convertedLink.replace('@temp@', '?path=/story/docs-');
      } else {
        convertedLink = convertedLink.replace(
          '@temp@',
          `?path=/story/docs-${directory}-`
        );
      }

      const newLine = line.replace(link, convertedLink);

      convertedContent += newLine + '\n';
    } else {
      convertedContent += line + '\n';
    }
  });

  let fileName = '';
  if (baseFileName === 'README.md') {
    fileName = 'introduction.stories.mdx';
  } else {
    fileName = baseFileName
      .replace('.md', '.stories.mdx')
      .replace('_', '-')
      .toLowerCase();
  }
  // Output the file to the output folder
  fs.writeFileSync(
    path.resolve(__dirname, output, fileName),
    convertedContent,
    'utf8'
  );
};

// Execute the script
(function () {
  // Check the output dir exists and create it if not
  if (!fs.existsSync(path.resolve(__dirname, output))) {
    fs.mkdirSync(path.resolve(__dirname, output));
  } else {
    // If the output dir exists, delete all files in it so we can start fresh
    rimraf.sync(path.resolve(__dirname, output));
    fs.mkdirSync(path.resolve(__dirname, output));
  }
  // Create the root README file
  fs.writeFileSync(
    path.resolve(__dirname, output, 'README.md'),
    rootReadMe,
    'utf8'
  );

  // Process the includes array
  return includes.map((d) => recurseDirectories(d));
})();
